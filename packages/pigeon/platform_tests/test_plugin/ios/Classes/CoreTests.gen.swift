// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Autogenerated from Pigeon, do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> FlutterError {
  return FlutterError(
    code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.",
    details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum AnEnum: Int {
  case one = 0
  case two = 1
  case three = 2
  case fortyTwo = 3
  case fourHundredTwentyTwo = 4
}

/// A class containing all supported types.
///
/// Generated class from Pigeon that represents data sent in messages.
struct AllTypes {
  var aBool: Bool
  var anInt: Int64
  var anInt64: Int64
  var aDouble: Double
  var aByteArray: FlutterStandardTypedData
  var a4ByteArray: FlutterStandardTypedData
  var a8ByteArray: FlutterStandardTypedData
  var aFloatArray: FlutterStandardTypedData
  var aList: [Any?]
  var aMap: [AnyHashable: Any?]
  var anEnum: AnEnum
  var aString: String
  var anObject: Any

  static func fromList(_ list: [Any?]) -> AllTypes? {
    let aBool = list[0] as! Bool
    let anInt = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    let anInt64 = list[2] is Int64 ? list[2] as! Int64 : Int64(list[2] as! Int32)
    let aDouble = list[3] as! Double
    let aByteArray = list[4] as! FlutterStandardTypedData
    let a4ByteArray = list[5] as! FlutterStandardTypedData
    let a8ByteArray = list[6] as! FlutterStandardTypedData
    let aFloatArray = list[7] as! FlutterStandardTypedData
    let aList = list[8] as! [Any?]
    let aMap = list[9] as! [AnyHashable: Any?]
    let anEnum = AnEnum(rawValue: list[10] as! Int)!
    let aString = list[11] as! String
    let anObject = list[12]!

    return AllTypes(
      aBool: aBool,
      anInt: anInt,
      anInt64: anInt64,
      aDouble: aDouble,
      aByteArray: aByteArray,
      a4ByteArray: a4ByteArray,
      a8ByteArray: a8ByteArray,
      aFloatArray: aFloatArray,
      aList: aList,
      aMap: aMap,
      anEnum: anEnum,
      aString: aString,
      anObject: anObject
    )
  }
  func toList() -> [Any?] {
    return [
      aBool,
      anInt,
      anInt64,
      aDouble,
      aByteArray,
      a4ByteArray,
      a8ByteArray,
      aFloatArray,
      aList,
      aMap,
      anEnum.rawValue,
      aString,
      anObject,
    ]
  }
}

/// A class containing all supported nullable types.
///
/// Generated class from Pigeon that represents data sent in messages.
struct AllNullableTypes {
  var aNullableBool: Bool? = nil
  var aNullableInt: Int64? = nil
  var aNullableInt64: Int64? = nil
  var aNullableDouble: Double? = nil
  var aNullableByteArray: FlutterStandardTypedData? = nil
  var aNullable4ByteArray: FlutterStandardTypedData? = nil
  var aNullable8ByteArray: FlutterStandardTypedData? = nil
  var aNullableFloatArray: FlutterStandardTypedData? = nil
  var aNullableList: [Any?]? = nil
  var aNullableMap: [AnyHashable: Any?]? = nil
  var nullableNestedList: [[Bool?]?]? = nil
  var nullableMapWithAnnotations: [String?: String?]? = nil
  var nullableMapWithObject: [String?: Any?]? = nil
  var aNullableEnum: AnEnum? = nil
  var aNullableString: String? = nil
  var aNullableObject: Any? = nil

  static func fromList(_ list: [Any?]) -> AllNullableTypes? {
    let aNullableBool: Bool? = nilOrValue(list[0])
    let aNullableInt: Int64? =
      isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))
    let aNullableInt64: Int64? =
      isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))
    let aNullableDouble: Double? = nilOrValue(list[3])
    let aNullableByteArray: FlutterStandardTypedData? = nilOrValue(list[4])
    let aNullable4ByteArray: FlutterStandardTypedData? = nilOrValue(list[5])
    let aNullable8ByteArray: FlutterStandardTypedData? = nilOrValue(list[6])
    let aNullableFloatArray: FlutterStandardTypedData? = nilOrValue(list[7])
    let aNullableList: [Any?]? = nilOrValue(list[8])
    let aNullableMap: [AnyHashable: Any?]? = nilOrValue(list[9])
    let nullableNestedList: [[Bool?]?]? = nilOrValue(list[10])
    let nullableMapWithAnnotations: [String?: String?]? = nilOrValue(list[11])
    let nullableMapWithObject: [String?: Any?]? = nilOrValue(list[12])
    var aNullableEnum: AnEnum? = nil
    let aNullableEnumEnumVal: Int? = nilOrValue(list[13])
    if let aNullableEnumRawValue = aNullableEnumEnumVal {
      aNullableEnum = AnEnum(rawValue: aNullableEnumRawValue)!
    }
    let aNullableString: String? = nilOrValue(list[14])
    let aNullableObject: Any? = list[15]

    return AllNullableTypes(
      aNullableBool: aNullableBool,
      aNullableInt: aNullableInt,
      aNullableInt64: aNullableInt64,
      aNullableDouble: aNullableDouble,
      aNullableByteArray: aNullableByteArray,
      aNullable4ByteArray: aNullable4ByteArray,
      aNullable8ByteArray: aNullable8ByteArray,
      aNullableFloatArray: aNullableFloatArray,
      aNullableList: aNullableList,
      aNullableMap: aNullableMap,
      nullableNestedList: nullableNestedList,
      nullableMapWithAnnotations: nullableMapWithAnnotations,
      nullableMapWithObject: nullableMapWithObject,
      aNullableEnum: aNullableEnum,
      aNullableString: aNullableString,
      aNullableObject: aNullableObject
    )
  }
  func toList() -> [Any?] {
    return [
      aNullableBool,
      aNullableInt,
      aNullableInt64,
      aNullableDouble,
      aNullableByteArray,
      aNullable4ByteArray,
      aNullable8ByteArray,
      aNullableFloatArray,
      aNullableList,
      aNullableMap,
      nullableNestedList,
      nullableMapWithAnnotations,
      nullableMapWithObject,
      aNullableEnum?.rawValue,
      aNullableString,
      aNullableObject,
    ]
  }
}

/// A class for testing nested class handling.
///
/// This is needed to test nested nullable and non-nullable classes,
/// `AllNullableTypes` is non-nullable here as it is easier to instantiate
/// than `AllTypes` when testing doesn't require both (ie. testing null classes).
///
/// Generated class from Pigeon that represents data sent in messages.
struct AllClassesWrapper {
  var allNullableTypes: AllNullableTypes
  var allTypes: AllTypes? = nil

  static func fromList(_ list: [Any?]) -> AllClassesWrapper? {
    let allNullableTypes = AllNullableTypes.fromList(list[0] as! [Any?])!
    var allTypes: AllTypes? = nil
    if let allTypesList: [Any?] = nilOrValue(list[1]) {
      allTypes = AllTypes.fromList(allTypesList)
    }

    return AllClassesWrapper(
      allNullableTypes: allNullableTypes,
      allTypes: allTypes
    )
  }
  func toList() -> [Any?] {
    return [
      allNullableTypes.toList(),
      allTypes?.toList(),
    ]
  }
}

/// A data class containing a List, used in unit tests.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TestMessage {
  var testList: [Any?]? = nil

  static func fromList(_ list: [Any?]) -> TestMessage? {
    let testList: [Any?]? = nilOrValue(list[0])

    return TestMessage(
      testList: testList
    )
  }
  func toList() -> [Any?] {
    return [
      testList
    ]
  }
}

private class HostIntegrationCoreApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return AllClassesWrapper.fromList(self.readValue() as! [Any?])
    case 129:
      return AllNullableTypes.fromList(self.readValue() as! [Any?])
    case 130:
      return AllTypes.fromList(self.readValue() as! [Any?])
    case 131:
      return TestMessage.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class HostIntegrationCoreApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AllClassesWrapper {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? AllNullableTypes {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? AllTypes {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? TestMessage {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class HostIntegrationCoreApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return HostIntegrationCoreApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return HostIntegrationCoreApiCodecWriter(data: data)
  }
}

class HostIntegrationCoreApiCodec: FlutterStandardMessageCodec {
  static let shared = HostIntegrationCoreApiCodec(
    readerWriter: HostIntegrationCoreApiCodecReaderWriter())
}

/// The core interface that each host language plugin must implement in
/// platform_test integration tests.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol HostIntegrationCoreApi {
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  func noop() throws
  /// Returns the passed object, to test serialization and deserialization.
  func echo(_ everything: AllTypes) throws -> AllTypes
  /// Returns an error, to test error handling.
  func throwError() throws -> Any?
  /// Returns an error from a void function, to test error handling.
  func throwErrorFromVoid() throws
  /// Returns a Flutter error, to test error handling.
  func throwFlutterError() throws -> Any?
  /// Returns passed in int.
  func echo(_ anInt: Int64) throws -> Int64
  /// Returns passed in double.
  func echo(_ aDouble: Double) throws -> Double
  /// Returns the passed in boolean.
  func echo(_ aBool: Bool) throws -> Bool
  /// Returns the passed in string.
  func echo(_ aString: String) throws -> String
  /// Returns the passed in Uint8List.
  func echo(_ aUint8List: FlutterStandardTypedData) throws -> FlutterStandardTypedData
  /// Returns the passed in generic Object.
  func echo(_ anObject: Any) throws -> Any
  /// Returns the passed list, to test serialization and deserialization.
  func echo(_ aList: [Any?]) throws -> [Any?]
  /// Returns the passed map, to test serialization and deserialization.
  func echo(_ aMap: [String?: Any?]) throws -> [String?: Any?]
  /// Returns the passed map to test nested class serialization and deserialization.
  func echo(_ wrapper: AllClassesWrapper) throws -> AllClassesWrapper
  /// Returns the passed enum to test serialization and deserialization.
  func echo(_ anEnum: AnEnum) throws -> AnEnum
  /// Returns the default string.
  func echoNamedDefault(_ aString: String) throws -> String
  /// Returns passed in double.
  func echoOptionalDefault(_ aDouble: Double) throws -> Double
  /// Returns passed in int.
  func echoRequired(_ anInt: Int64) throws -> Int64
  /// Returns the passed object, to test serialization and deserialization.
  func echo(_ everything: AllNullableTypes?) throws -> AllNullableTypes?
  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  func extractNestedNullableString(from wrapper: AllClassesWrapper) throws -> String?
  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  func createNestedObject(with nullableString: String?) throws -> AllClassesWrapper
  /// Returns passed in arguments of multiple types.
  func sendMultipleNullableTypes(
    aBool aNullableBool: Bool?, anInt aNullableInt: Int64?, aString aNullableString: String?
  ) throws -> AllNullableTypes
  /// Returns passed in int.
  func echo(_ aNullableInt: Int64?) throws -> Int64?
  /// Returns passed in double.
  func echo(_ aNullableDouble: Double?) throws -> Double?
  /// Returns the passed in boolean.
  func echo(_ aNullableBool: Bool?) throws -> Bool?
  /// Returns the passed in string.
  func echo(_ aNullableString: String?) throws -> String?
  /// Returns the passed in Uint8List.
  func echo(_ aNullableUint8List: FlutterStandardTypedData?) throws -> FlutterStandardTypedData?
  /// Returns the passed in generic Object.
  func echo(_ aNullableObject: Any?) throws -> Any?
  /// Returns the passed list, to test serialization and deserialization.
  func echoNullable(_ aNullableList: [Any?]?) throws -> [Any?]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullable(_ aNullableMap: [String?: Any?]?) throws -> [String?: Any?]?
  func echoNullable(_ anEnum: AnEnum?) throws -> AnEnum?
  /// Returns passed in int.
  func echoOptional(_ aNullableInt: Int64?) throws -> Int64?
  /// Returns the passed in string.
  func echoNamed(_ aNullableString: String?) throws -> String?
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic asynchronous calling.
  func noopAsync(completion: @escaping (Result<Void, Error>) -> Void)
  /// Returns passed in int asynchronously.
  func echoAsync(_ anInt: Int64, completion: @escaping (Result<Int64, Error>) -> Void)
  /// Returns passed in double asynchronously.
  func echoAsync(_ aDouble: Double, completion: @escaping (Result<Double, Error>) -> Void)
  /// Returns the passed in boolean asynchronously.
  func echoAsync(_ aBool: Bool, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Returns the passed string asynchronously.
  func echoAsync(_ aString: String, completion: @escaping (Result<String, Error>) -> Void)
  /// Returns the passed in Uint8List asynchronously.
  func echoAsync(
    _ aUint8List: FlutterStandardTypedData,
    completion: @escaping (Result<FlutterStandardTypedData, Error>) -> Void)
  /// Returns the passed in generic Object asynchronously.
  func echoAsync(_ anObject: Any, completion: @escaping (Result<Any, Error>) -> Void)
  /// Returns the passed list, to test asynchronous serialization and deserialization.
  func echoAsync(_ aList: [Any?], completion: @escaping (Result<[Any?], Error>) -> Void)
  /// Returns the passed map, to test asynchronous serialization and deserialization.
  func echoAsync(
    _ aMap: [String?: Any?], completion: @escaping (Result<[String?: Any?], Error>) -> Void)
  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  func echoAsync(_ anEnum: AnEnum, completion: @escaping (Result<AnEnum, Error>) -> Void)
  /// Responds with an error from an async function returning a value.
  func throwAsyncError(completion: @escaping (Result<Any?, Error>) -> Void)
  /// Responds with an error from an async void function.
  func throwAsyncErrorFromVoid(completion: @escaping (Result<Void, Error>) -> Void)
  /// Responds with a Flutter error from an async function returning a value.
  func throwAsyncFlutterError(completion: @escaping (Result<Any?, Error>) -> Void)
  /// Returns the passed object, to test async serialization and deserialization.
  func echoAsync(_ everything: AllTypes, completion: @escaping (Result<AllTypes, Error>) -> Void)
  /// Returns the passed object, to test serialization and deserialization.
  func echoAsync(
    _ everything: AllNullableTypes?,
    completion: @escaping (Result<AllNullableTypes?, Error>) -> Void)
  /// Returns passed in int asynchronously.
  func echoAsyncNullable(_ anInt: Int64?, completion: @escaping (Result<Int64?, Error>) -> Void)
  /// Returns passed in double asynchronously.
  func echoAsyncNullable(_ aDouble: Double?, completion: @escaping (Result<Double?, Error>) -> Void)
  /// Returns the passed in boolean asynchronously.
  func echoAsyncNullable(_ aBool: Bool?, completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Returns the passed string asynchronously.
  func echoAsyncNullable(_ aString: String?, completion: @escaping (Result<String?, Error>) -> Void)
  /// Returns the passed in Uint8List asynchronously.
  func echoAsyncNullable(
    _ aUint8List: FlutterStandardTypedData?,
    completion: @escaping (Result<FlutterStandardTypedData?, Error>) -> Void)
  /// Returns the passed in generic Object asynchronously.
  func echoAsyncNullable(_ anObject: Any?, completion: @escaping (Result<Any?, Error>) -> Void)
  /// Returns the passed list, to test asynchronous serialization and deserialization.
  func echoAsyncNullable(_ aList: [Any?]?, completion: @escaping (Result<[Any?]?, Error>) -> Void)
  /// Returns the passed map, to test asynchronous serialization and deserialization.
  func echoAsyncNullable(
    _ aMap: [String?: Any?]?, completion: @escaping (Result<[String?: Any?]?, Error>) -> Void)
  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  func echoAsyncNullable(_ anEnum: AnEnum?, completion: @escaping (Result<AnEnum?, Error>) -> Void)
  func callFlutterNoop(completion: @escaping (Result<Void, Error>) -> Void)
  func callFlutterThrowError(completion: @escaping (Result<Any?, Error>) -> Void)
  func callFlutterThrowErrorFromVoid(completion: @escaping (Result<Void, Error>) -> Void)
  func callFlutterEcho(
    _ everything: AllTypes, completion: @escaping (Result<AllTypes, Error>) -> Void)
  func callFlutterEcho(
    _ everything: AllNullableTypes?,
    completion: @escaping (Result<AllNullableTypes?, Error>) -> Void)
  func callFlutterSendMultipleNullableTypes(
    aBool aNullableBool: Bool?, anInt aNullableInt: Int64?, aString aNullableString: String?,
    completion: @escaping (Result<AllNullableTypes, Error>) -> Void)
  func callFlutterEcho(_ aBool: Bool, completion: @escaping (Result<Bool, Error>) -> Void)
  func callFlutterEcho(_ anInt: Int64, completion: @escaping (Result<Int64, Error>) -> Void)
  func callFlutterEcho(_ aDouble: Double, completion: @escaping (Result<Double, Error>) -> Void)
  func callFlutterEcho(_ aString: String, completion: @escaping (Result<String, Error>) -> Void)
  func callFlutterEcho(
    _ aList: FlutterStandardTypedData,
    completion: @escaping (Result<FlutterStandardTypedData, Error>) -> Void)
  func callFlutterEcho(_ aList: [Any?], completion: @escaping (Result<[Any?], Error>) -> Void)
  func callFlutterEcho(
    _ aMap: [String?: Any?], completion: @escaping (Result<[String?: Any?], Error>) -> Void)
  func callFlutterEcho(_ anEnum: AnEnum, completion: @escaping (Result<AnEnum, Error>) -> Void)
  func callFlutterEchoNullable(_ aBool: Bool?, completion: @escaping (Result<Bool?, Error>) -> Void)
  func callFlutterEchoNullable(
    _ anInt: Int64?, completion: @escaping (Result<Int64?, Error>) -> Void)
  func callFlutterEchoNullable(
    _ aDouble: Double?, completion: @escaping (Result<Double?, Error>) -> Void)
  func callFlutterEchoNullable(
    _ aString: String?, completion: @escaping (Result<String?, Error>) -> Void)
  func callFlutterEchoNullable(
    _ aList: FlutterStandardTypedData?,
    completion: @escaping (Result<FlutterStandardTypedData?, Error>) -> Void)
  func callFlutterEchoNullable(
    _ aList: [Any?]?, completion: @escaping (Result<[Any?]?, Error>) -> Void)
  func callFlutterEchoNullable(
    _ aMap: [String?: Any?]?, completion: @escaping (Result<[String?: Any?]?, Error>) -> Void)
  func callFlutterNullableEcho(
    _ anEnum: AnEnum?, completion: @escaping (Result<AnEnum?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class HostIntegrationCoreApiSetup {
  /// The codec used by HostIntegrationCoreApi.
  static var codec: FlutterStandardMessageCodec { HostIntegrationCoreApiCodec.shared }
  /// Sets up an instance of `HostIntegrationCoreApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: HostIntegrationCoreApi?) {
    /// A no-op function taking no arguments and returning no value, to sanity
    /// test basic calling.
    let noopChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.noop",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      noopChannel.setMessageHandler { _, reply in
        do {
          try api.noop()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      noopChannel.setMessageHandler(nil)
    }
    /// Returns the passed object, to test serialization and deserialization.
    let echoAllTypesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAllTypes",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAllTypesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let everythingArg = args[0] as! AllTypes
        do {
          let result = try api.echo(everythingArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoAllTypesChannel.setMessageHandler(nil)
    }
    /// Returns an error, to test error handling.
    let throwErrorChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.throwError",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwErrorChannel.setMessageHandler { _, reply in
        do {
          let result = try api.throwError()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      throwErrorChannel.setMessageHandler(nil)
    }
    /// Returns an error from a void function, to test error handling.
    let throwErrorFromVoidChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.throwErrorFromVoid",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwErrorFromVoidChannel.setMessageHandler { _, reply in
        do {
          try api.throwErrorFromVoid()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      throwErrorFromVoidChannel.setMessageHandler(nil)
    }
    /// Returns a Flutter error, to test error handling.
    let throwFlutterErrorChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.throwFlutterError",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwFlutterErrorChannel.setMessageHandler { _, reply in
        do {
          let result = try api.throwFlutterError()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      throwFlutterErrorChannel.setMessageHandler(nil)
    }
    /// Returns passed in int.
    let echoIntChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anIntArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.echo(anIntArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoIntChannel.setMessageHandler(nil)
    }
    /// Returns passed in double.
    let echoDoubleChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aDoubleArg = args[0] as! Double
        do {
          let result = try api.echo(aDoubleArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoDoubleChannel.setMessageHandler(nil)
    }
    /// Returns the passed in boolean.
    let echoBoolChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aBoolArg = args[0] as! Bool
        do {
          let result = try api.echo(aBoolArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoBoolChannel.setMessageHandler(nil)
    }
    /// Returns the passed in string.
    let echoStringChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aStringArg = args[0] as! String
        do {
          let result = try api.echo(aStringArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoStringChannel.setMessageHandler(nil)
    }
    /// Returns the passed in Uint8List.
    let echoUint8ListChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aUint8ListArg = args[0] as! FlutterStandardTypedData
        do {
          let result = try api.echo(aUint8ListArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoUint8ListChannel.setMessageHandler(nil)
    }
    /// Returns the passed in generic Object.
    let echoObjectChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoObject",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoObjectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anObjectArg = args[0]!
        do {
          let result = try api.echo(anObjectArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoObjectChannel.setMessageHandler(nil)
    }
    /// Returns the passed list, to test serialization and deserialization.
    let echoListChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aListArg = args[0] as! [Any?]
        do {
          let result = try api.echo(aListArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoListChannel.setMessageHandler(nil)
    }
    /// Returns the passed map, to test serialization and deserialization.
    let echoMapChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aMapArg = args[0] as! [String?: Any?]
        do {
          let result = try api.echo(aMapArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoMapChannel.setMessageHandler(nil)
    }
    /// Returns the passed map to test nested class serialization and deserialization.
    let echoClassWrapperChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoClassWrapper",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoClassWrapperChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let wrapperArg = args[0] as! AllClassesWrapper
        do {
          let result = try api.echo(wrapperArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoClassWrapperChannel.setMessageHandler(nil)
    }
    /// Returns the passed enum to test serialization and deserialization.
    let echoEnumChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anEnumArg = AnEnum(rawValue: args[0] as! Int)!
        do {
          let result = try api.echo(anEnumArg)
          reply(wrapResult(result.rawValue))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoEnumChannel.setMessageHandler(nil)
    }
    /// Returns the default string.
    let echoNamedDefaultStringChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoNamedDefaultString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNamedDefaultStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aStringArg = args[0] as! String
        do {
          let result = try api.echoNamedDefault(aStringArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNamedDefaultStringChannel.setMessageHandler(nil)
    }
    /// Returns passed in double.
    let echoOptionalDefaultDoubleChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoOptionalDefaultDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoOptionalDefaultDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aDoubleArg = args[0] as! Double
        do {
          let result = try api.echoOptionalDefault(aDoubleArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoOptionalDefaultDoubleChannel.setMessageHandler(nil)
    }
    /// Returns passed in int.
    let echoRequiredIntChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoRequiredInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoRequiredIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anIntArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          let result = try api.echoRequired(anIntArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoRequiredIntChannel.setMessageHandler(nil)
    }
    /// Returns the passed object, to test serialization and deserialization.
    let echoAllNullableTypesChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAllNullableTypes",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAllNullableTypesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let everythingArg: AllNullableTypes? = nilOrValue(args[0])
        do {
          let result = try api.echo(everythingArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoAllNullableTypesChannel.setMessageHandler(nil)
    }
    /// Returns the inner `aString` value from the wrapped object, to test
    /// sending of nested objects.
    let extractNestedNullableStringChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.extractNestedNullableString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      extractNestedNullableStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let wrapperArg = args[0] as! AllClassesWrapper
        do {
          let result = try api.extractNestedNullableString(from: wrapperArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      extractNestedNullableStringChannel.setMessageHandler(nil)
    }
    /// Returns the inner `aString` value from the wrapped object, to test
    /// sending of nested objects.
    let createNestedNullableStringChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.createNestedNullableString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createNestedNullableStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let nullableStringArg: String? = nilOrValue(args[0])
        do {
          let result = try api.createNestedObject(with: nullableStringArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createNestedNullableStringChannel.setMessageHandler(nil)
    }
    /// Returns passed in arguments of multiple types.
    let sendMultipleNullableTypesChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.sendMultipleNullableTypes",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      sendMultipleNullableTypesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableBoolArg: Bool? = nilOrValue(args[0])
        let aNullableIntArg: Int64? =
          isNullish(args[1])
          ? nil : (args[1] is Int64? ? args[1] as! Int64? : Int64(args[1] as! Int32))
        let aNullableStringArg: String? = nilOrValue(args[2])
        do {
          let result = try api.sendMultipleNullableTypes(
            aBool: aNullableBoolArg, anInt: aNullableIntArg, aString: aNullableStringArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      sendMultipleNullableTypesChannel.setMessageHandler(nil)
    }
    /// Returns passed in int.
    let echoNullableIntChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoNullableInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableIntArg: Int64? =
          isNullish(args[0])
          ? nil : (args[0] is Int64? ? args[0] as! Int64? : Int64(args[0] as! Int32))
        do {
          let result = try api.echo(aNullableIntArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableIntChannel.setMessageHandler(nil)
    }
    /// Returns passed in double.
    let echoNullableDoubleChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoNullableDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableDoubleArg: Double? = nilOrValue(args[0])
        do {
          let result = try api.echo(aNullableDoubleArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableDoubleChannel.setMessageHandler(nil)
    }
    /// Returns the passed in boolean.
    let echoNullableBoolChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoNullableBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableBoolArg: Bool? = nilOrValue(args[0])
        do {
          let result = try api.echo(aNullableBoolArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableBoolChannel.setMessageHandler(nil)
    }
    /// Returns the passed in string.
    let echoNullableStringChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoNullableString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableStringArg: String? = nilOrValue(args[0])
        do {
          let result = try api.echo(aNullableStringArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableStringChannel.setMessageHandler(nil)
    }
    /// Returns the passed in Uint8List.
    let echoNullableUint8ListChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoNullableUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableUint8ListArg: FlutterStandardTypedData? = nilOrValue(args[0])
        do {
          let result = try api.echo(aNullableUint8ListArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableUint8ListChannel.setMessageHandler(nil)
    }
    /// Returns the passed in generic Object.
    let echoNullableObjectChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoNullableObject",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableObjectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableObjectArg: Any? = args[0]
        do {
          let result = try api.echo(aNullableObjectArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableObjectChannel.setMessageHandler(nil)
    }
    /// Returns the passed list, to test serialization and deserialization.
    let echoNullableListChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoNullableList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableListArg: [Any?]? = nilOrValue(args[0])
        do {
          let result = try api.echoNullable(aNullableListArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableListChannel.setMessageHandler(nil)
    }
    /// Returns the passed map, to test serialization and deserialization.
    let echoNullableMapChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoNullableMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableMapArg: [String?: Any?]? = nilOrValue(args[0])
        do {
          let result = try api.echoNullable(aNullableMapArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableMapChannel.setMessageHandler(nil)
    }
    let echoNullableEnumChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoNullableEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anEnumArg: AnEnum? = isNullish(args[0]) ? nil : AnEnum(rawValue: args[0] as! Int)!
        do {
          let result = try api.echoNullable(anEnumArg)
          reply(wrapResult(result?.rawValue))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableEnumChannel.setMessageHandler(nil)
    }
    /// Returns passed in int.
    let echoOptionalNullableIntChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoOptionalNullableInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoOptionalNullableIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableIntArg: Int64? =
          isNullish(args[0])
          ? nil : (args[0] is Int64? ? args[0] as! Int64? : Int64(args[0] as! Int32))
        do {
          let result = try api.echoOptional(aNullableIntArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoOptionalNullableIntChannel.setMessageHandler(nil)
    }
    /// Returns the passed in string.
    let echoNamedNullableStringChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoNamedNullableString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNamedNullableStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableStringArg: String? = nilOrValue(args[0])
        do {
          let result = try api.echoNamed(aNullableStringArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNamedNullableStringChannel.setMessageHandler(nil)
    }
    /// A no-op function taking no arguments and returning no value, to sanity
    /// test basic asynchronous calling.
    let noopAsyncChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.noopAsync",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      noopAsyncChannel.setMessageHandler { _, reply in
        api.noopAsync { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      noopAsyncChannel.setMessageHandler(nil)
    }
    /// Returns passed in int asynchronously.
    let echoAsyncIntChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anIntArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        api.echoAsync(anIntArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncIntChannel.setMessageHandler(nil)
    }
    /// Returns passed in double asynchronously.
    let echoAsyncDoubleChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aDoubleArg = args[0] as! Double
        api.echoAsync(aDoubleArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncDoubleChannel.setMessageHandler(nil)
    }
    /// Returns the passed in boolean asynchronously.
    let echoAsyncBoolChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aBoolArg = args[0] as! Bool
        api.echoAsync(aBoolArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncBoolChannel.setMessageHandler(nil)
    }
    /// Returns the passed string asynchronously.
    let echoAsyncStringChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aStringArg = args[0] as! String
        api.echoAsync(aStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncStringChannel.setMessageHandler(nil)
    }
    /// Returns the passed in Uint8List asynchronously.
    let echoAsyncUint8ListChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aUint8ListArg = args[0] as! FlutterStandardTypedData
        api.echoAsync(aUint8ListArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncUint8ListChannel.setMessageHandler(nil)
    }
    /// Returns the passed in generic Object asynchronously.
    let echoAsyncObjectChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncObject",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncObjectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anObjectArg = args[0]!
        api.echoAsync(anObjectArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncObjectChannel.setMessageHandler(nil)
    }
    /// Returns the passed list, to test asynchronous serialization and deserialization.
    let echoAsyncListChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aListArg = args[0] as! [Any?]
        api.echoAsync(aListArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncListChannel.setMessageHandler(nil)
    }
    /// Returns the passed map, to test asynchronous serialization and deserialization.
    let echoAsyncMapChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aMapArg = args[0] as! [String?: Any?]
        api.echoAsync(aMapArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncMapChannel.setMessageHandler(nil)
    }
    /// Returns the passed enum, to test asynchronous serialization and deserialization.
    let echoAsyncEnumChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anEnumArg = AnEnum(rawValue: args[0] as! Int)!
        api.echoAsync(anEnumArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncEnumChannel.setMessageHandler(nil)
    }
    /// Responds with an error from an async function returning a value.
    let throwAsyncErrorChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.throwAsyncError",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwAsyncErrorChannel.setMessageHandler { _, reply in
        api.throwAsyncError { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      throwAsyncErrorChannel.setMessageHandler(nil)
    }
    /// Responds with an error from an async void function.
    let throwAsyncErrorFromVoidChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.throwAsyncErrorFromVoid",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwAsyncErrorFromVoidChannel.setMessageHandler { _, reply in
        api.throwAsyncErrorFromVoid { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      throwAsyncErrorFromVoidChannel.setMessageHandler(nil)
    }
    /// Responds with a Flutter error from an async function returning a value.
    let throwAsyncFlutterErrorChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.throwAsyncFlutterError",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwAsyncFlutterErrorChannel.setMessageHandler { _, reply in
        api.throwAsyncFlutterError { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      throwAsyncFlutterErrorChannel.setMessageHandler(nil)
    }
    /// Returns the passed object, to test async serialization and deserialization.
    let echoAsyncAllTypesChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncAllTypes",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncAllTypesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let everythingArg = args[0] as! AllTypes
        api.echoAsync(everythingArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncAllTypesChannel.setMessageHandler(nil)
    }
    /// Returns the passed object, to test serialization and deserialization.
    let echoAsyncNullableAllNullableTypesChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncNullableAllNullableTypes",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableAllNullableTypesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let everythingArg: AllNullableTypes? = nilOrValue(args[0])
        api.echoAsync(everythingArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableAllNullableTypesChannel.setMessageHandler(nil)
    }
    /// Returns passed in int asynchronously.
    let echoAsyncNullableIntChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncNullableInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anIntArg: Int64? =
          isNullish(args[0])
          ? nil : (args[0] is Int64? ? args[0] as! Int64? : Int64(args[0] as! Int32))
        api.echoAsyncNullable(anIntArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableIntChannel.setMessageHandler(nil)
    }
    /// Returns passed in double asynchronously.
    let echoAsyncNullableDoubleChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncNullableDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aDoubleArg: Double? = nilOrValue(args[0])
        api.echoAsyncNullable(aDoubleArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableDoubleChannel.setMessageHandler(nil)
    }
    /// Returns the passed in boolean asynchronously.
    let echoAsyncNullableBoolChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncNullableBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aBoolArg: Bool? = nilOrValue(args[0])
        api.echoAsyncNullable(aBoolArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableBoolChannel.setMessageHandler(nil)
    }
    /// Returns the passed string asynchronously.
    let echoAsyncNullableStringChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncNullableString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aStringArg: String? = nilOrValue(args[0])
        api.echoAsyncNullable(aStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableStringChannel.setMessageHandler(nil)
    }
    /// Returns the passed in Uint8List asynchronously.
    let echoAsyncNullableUint8ListChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncNullableUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aUint8ListArg: FlutterStandardTypedData? = nilOrValue(args[0])
        api.echoAsyncNullable(aUint8ListArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableUint8ListChannel.setMessageHandler(nil)
    }
    /// Returns the passed in generic Object asynchronously.
    let echoAsyncNullableObjectChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncNullableObject",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableObjectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anObjectArg: Any? = args[0]
        api.echoAsyncNullable(anObjectArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableObjectChannel.setMessageHandler(nil)
    }
    /// Returns the passed list, to test asynchronous serialization and deserialization.
    let echoAsyncNullableListChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncNullableList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aListArg: [Any?]? = nilOrValue(args[0])
        api.echoAsyncNullable(aListArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableListChannel.setMessageHandler(nil)
    }
    /// Returns the passed map, to test asynchronous serialization and deserialization.
    let echoAsyncNullableMapChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncNullableMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aMapArg: [String?: Any?]? = nilOrValue(args[0])
        api.echoAsyncNullable(aMapArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableMapChannel.setMessageHandler(nil)
    }
    /// Returns the passed enum, to test asynchronous serialization and deserialization.
    let echoAsyncNullableEnumChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.echoAsyncNullableEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anEnumArg: AnEnum? = isNullish(args[0]) ? nil : AnEnum(rawValue: args[0] as! Int)!
        api.echoAsyncNullable(anEnumArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableEnumChannel.setMessageHandler(nil)
    }
    let callFlutterNoopChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterNoop",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterNoopChannel.setMessageHandler { _, reply in
        api.callFlutterNoop { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterNoopChannel.setMessageHandler(nil)
    }
    let callFlutterThrowErrorChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterThrowError",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterThrowErrorChannel.setMessageHandler { _, reply in
        api.callFlutterThrowError { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterThrowErrorChannel.setMessageHandler(nil)
    }
    let callFlutterThrowErrorFromVoidChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterThrowErrorFromVoid",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterThrowErrorFromVoidChannel.setMessageHandler { _, reply in
        api.callFlutterThrowErrorFromVoid { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterThrowErrorFromVoidChannel.setMessageHandler(nil)
    }
    let callFlutterEchoAllTypesChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoAllTypes",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoAllTypesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let everythingArg = args[0] as! AllTypes
        api.callFlutterEcho(everythingArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoAllTypesChannel.setMessageHandler(nil)
    }
    let callFlutterEchoAllNullableTypesChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoAllNullableTypes",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoAllNullableTypesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let everythingArg: AllNullableTypes? = nilOrValue(args[0])
        api.callFlutterEcho(everythingArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoAllNullableTypesChannel.setMessageHandler(nil)
    }
    let callFlutterSendMultipleNullableTypesChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterSendMultipleNullableTypes",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterSendMultipleNullableTypesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aNullableBoolArg: Bool? = nilOrValue(args[0])
        let aNullableIntArg: Int64? =
          isNullish(args[1])
          ? nil : (args[1] is Int64? ? args[1] as! Int64? : Int64(args[1] as! Int32))
        let aNullableStringArg: String? = nilOrValue(args[2])
        api.callFlutterSendMultipleNullableTypes(
          aBool: aNullableBoolArg, anInt: aNullableIntArg, aString: aNullableStringArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterSendMultipleNullableTypesChannel.setMessageHandler(nil)
    }
    let callFlutterEchoBoolChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aBoolArg = args[0] as! Bool
        api.callFlutterEcho(aBoolArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoBoolChannel.setMessageHandler(nil)
    }
    let callFlutterEchoIntChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anIntArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        api.callFlutterEcho(anIntArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoIntChannel.setMessageHandler(nil)
    }
    let callFlutterEchoDoubleChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aDoubleArg = args[0] as! Double
        api.callFlutterEcho(aDoubleArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoDoubleChannel.setMessageHandler(nil)
    }
    let callFlutterEchoStringChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aStringArg = args[0] as! String
        api.callFlutterEcho(aStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoStringChannel.setMessageHandler(nil)
    }
    let callFlutterEchoUint8ListChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aListArg = args[0] as! FlutterStandardTypedData
        api.callFlutterEcho(aListArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoUint8ListChannel.setMessageHandler(nil)
    }
    let callFlutterEchoListChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aListArg = args[0] as! [Any?]
        api.callFlutterEcho(aListArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoListChannel.setMessageHandler(nil)
    }
    let callFlutterEchoMapChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aMapArg = args[0] as! [String?: Any?]
        api.callFlutterEcho(aMapArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoMapChannel.setMessageHandler(nil)
    }
    let callFlutterEchoEnumChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anEnumArg = AnEnum(rawValue: args[0] as! Int)!
        api.callFlutterEcho(anEnumArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoEnumChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableBoolChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aBoolArg: Bool? = nilOrValue(args[0])
        api.callFlutterEchoNullable(aBoolArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableBoolChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableIntChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anIntArg: Int64? =
          isNullish(args[0])
          ? nil : (args[0] is Int64? ? args[0] as! Int64? : Int64(args[0] as! Int32))
        api.callFlutterEchoNullable(anIntArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableIntChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableDoubleChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aDoubleArg: Double? = nilOrValue(args[0])
        api.callFlutterEchoNullable(aDoubleArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableDoubleChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableStringChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aStringArg: String? = nilOrValue(args[0])
        api.callFlutterEchoNullable(aStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableStringChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableUint8ListChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aListArg: FlutterStandardTypedData? = nilOrValue(args[0])
        api.callFlutterEchoNullable(aListArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableUint8ListChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableListChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aListArg: [Any?]? = nilOrValue(args[0])
        api.callFlutterEchoNullable(aListArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableListChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableMapChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aMapArg: [String?: Any?]? = nilOrValue(args[0])
        api.callFlutterEchoNullable(aMapArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableMapChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableEnumChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.pigeon_integration_tests.HostIntegrationCoreApi.callFlutterEchoNullableEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anEnumArg: AnEnum? = isNullish(args[0]) ? nil : AnEnum(rawValue: args[0] as! Int)!
        api.callFlutterNullableEcho(anEnumArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableEnumChannel.setMessageHandler(nil)
    }
  }
}
private class FlutterIntegrationCoreApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return AllClassesWrapper.fromList(self.readValue() as! [Any?])
    case 129:
      return AllNullableTypes.fromList(self.readValue() as! [Any?])
    case 130:
      return AllTypes.fromList(self.readValue() as! [Any?])
    case 131:
      return TestMessage.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class FlutterIntegrationCoreApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AllClassesWrapper {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? AllNullableTypes {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? AllTypes {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? TestMessage {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class FlutterIntegrationCoreApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return FlutterIntegrationCoreApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return FlutterIntegrationCoreApiCodecWriter(data: data)
  }
}

class FlutterIntegrationCoreApiCodec: FlutterStandardMessageCodec {
  static let shared = FlutterIntegrationCoreApiCodec(
    readerWriter: FlutterIntegrationCoreApiCodecReaderWriter())
}

/// The core interface that the Dart platform_test code implements for host
/// integration tests to call into.
///
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol FlutterIntegrationCoreApiProtocol {
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  func noop(completion: @escaping (Result<Void, FlutterError>) -> Void)
  /// Responds with an error from an async function returning a value.
  func throwError(completion: @escaping (Result<Any?, FlutterError>) -> Void)
  /// Responds with an error from an async void function.
  func throwErrorFromVoid(completion: @escaping (Result<Void, FlutterError>) -> Void)
  /// Returns the passed object, to test serialization and deserialization.
  func echo(
    _ everythingArg: AllTypes, completion: @escaping (Result<AllTypes, FlutterError>) -> Void)
  /// Returns the passed object, to test serialization and deserialization.
  func echoNullable(
    _ everythingArg: AllNullableTypes?,
    completion: @escaping (Result<AllNullableTypes?, FlutterError>) -> Void)
  /// Returns passed in arguments of multiple types.
  ///
  /// Tests multiple-arity FlutterApi handling.
  func sendMultipleNullableTypes(
    aBool aNullableBoolArg: Bool?, anInt aNullableIntArg: Int64?,
    aString aNullableStringArg: String?,
    completion: @escaping (Result<AllNullableTypes, FlutterError>) -> Void)
  /// Returns the passed boolean, to test serialization and deserialization.
  func echo(_ aBoolArg: Bool, completion: @escaping (Result<Bool, FlutterError>) -> Void)
  /// Returns the passed int, to test serialization and deserialization.
  func echo(_ anIntArg: Int64, completion: @escaping (Result<Int64, FlutterError>) -> Void)
  /// Returns the passed double, to test serialization and deserialization.
  func echo(_ aDoubleArg: Double, completion: @escaping (Result<Double, FlutterError>) -> Void)
  /// Returns the passed string, to test serialization and deserialization.
  func echo(_ aStringArg: String, completion: @escaping (Result<String, FlutterError>) -> Void)
  /// Returns the passed byte list, to test serialization and deserialization.
  func echo(
    _ aListArg: FlutterStandardTypedData,
    completion: @escaping (Result<FlutterStandardTypedData, FlutterError>) -> Void)
  /// Returns the passed list, to test serialization and deserialization.
  func echo(_ aListArg: [Any?], completion: @escaping (Result<[Any?], FlutterError>) -> Void)
  /// Returns the passed map, to test serialization and deserialization.
  func echo(
    _ aMapArg: [String?: Any?],
    completion: @escaping (Result<[String?: Any?], FlutterError>) -> Void)
  /// Returns the passed enum to test serialization and deserialization.
  func echo(_ anEnumArg: AnEnum, completion: @escaping (Result<AnEnum, FlutterError>) -> Void)
  /// Returns the passed boolean, to test serialization and deserialization.
  func echoNullable(_ aBoolArg: Bool?, completion: @escaping (Result<Bool?, FlutterError>) -> Void)
  /// Returns the passed int, to test serialization and deserialization.
  func echoNullable(
    _ anIntArg: Int64?, completion: @escaping (Result<Int64?, FlutterError>) -> Void)
  /// Returns the passed double, to test serialization and deserialization.
  func echoNullable(
    _ aDoubleArg: Double?, completion: @escaping (Result<Double?, FlutterError>) -> Void)
  /// Returns the passed string, to test serialization and deserialization.
  func echoNullable(
    _ aStringArg: String?, completion: @escaping (Result<String?, FlutterError>) -> Void)
  /// Returns the passed byte list, to test serialization and deserialization.
  func echoNullable(
    _ aListArg: FlutterStandardTypedData?,
    completion: @escaping (Result<FlutterStandardTypedData?, FlutterError>) -> Void)
  /// Returns the passed list, to test serialization and deserialization.
  func echoNullable(
    _ aListArg: [Any?]?, completion: @escaping (Result<[Any?]?, FlutterError>) -> Void)
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullable(
    _ aMapArg: [String?: Any?]?,
    completion: @escaping (Result<[String?: Any?]?, FlutterError>) -> Void)
  /// Returns the passed enum to test serialization and deserialization.
  func echoNullable(
    _ anEnumArg: AnEnum?, completion: @escaping (Result<AnEnum?, FlutterError>) -> Void)
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic asynchronous calling.
  func noopAsync(completion: @escaping (Result<Void, FlutterError>) -> Void)
  /// Returns the passed in generic Object asynchronously.
  func echoAsync(_ aStringArg: String, completion: @escaping (Result<String, FlutterError>) -> Void)
}
class FlutterIntegrationCoreApi: FlutterIntegrationCoreApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return FlutterIntegrationCoreApiCodec.shared
  }
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  func noop(completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.noop"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Responds with an error from an async function returning a value.
  func throwError(completion: @escaping (Result<Any?, FlutterError>) -> Void) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.throwError"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        let result: Any? = listResponse[0]
        completion(.success(result))
      }
    }
  }
  /// Responds with an error from an async void function.
  func throwErrorFromVoid(completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.throwErrorFromVoid"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Returns the passed object, to test serialization and deserialization.
  func echo(
    _ everythingArg: AllTypes, completion: @escaping (Result<AllTypes, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoAllTypes"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([everythingArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! AllTypes
        completion(.success(result))
      }
    }
  }
  /// Returns the passed object, to test serialization and deserialization.
  func echoNullable(
    _ everythingArg: AllNullableTypes?,
    completion: @escaping (Result<AllNullableTypes?, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoAllNullableTypes"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([everythingArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        let result: AllNullableTypes? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }
  /// Returns passed in arguments of multiple types.
  ///
  /// Tests multiple-arity FlutterApi handling.
  func sendMultipleNullableTypes(
    aBool aNullableBoolArg: Bool?, anInt aNullableIntArg: Int64?,
    aString aNullableStringArg: String?,
    completion: @escaping (Result<AllNullableTypes, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.sendMultipleNullableTypes"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aNullableBoolArg, aNullableIntArg, aNullableStringArg] as [Any?]) {
      response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! AllNullableTypes
        completion(.success(result))
      }
    }
  }
  /// Returns the passed boolean, to test serialization and deserialization.
  func echo(_ aBoolArg: Bool, completion: @escaping (Result<Bool, FlutterError>) -> Void) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoBool"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aBoolArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! Bool
        completion(.success(result))
      }
    }
  }
  /// Returns the passed int, to test serialization and deserialization.
  func echo(_ anIntArg: Int64, completion: @escaping (Result<Int64, FlutterError>) -> Void) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoInt"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([anIntArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result =
          listResponse[0] is Int64 ? listResponse[0] as! Int64 : Int64(listResponse[0] as! Int32)
        completion(.success(result))
      }
    }
  }
  /// Returns the passed double, to test serialization and deserialization.
  func echo(_ aDoubleArg: Double, completion: @escaping (Result<Double, FlutterError>) -> Void) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoDouble"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aDoubleArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! Double
        completion(.success(result))
      }
    }
  }
  /// Returns the passed string, to test serialization and deserialization.
  func echo(_ aStringArg: String, completion: @escaping (Result<String, FlutterError>) -> Void) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoString"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aStringArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! String
        completion(.success(result))
      }
    }
  }
  /// Returns the passed byte list, to test serialization and deserialization.
  func echo(
    _ aListArg: FlutterStandardTypedData,
    completion: @escaping (Result<FlutterStandardTypedData, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoUint8List"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aListArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! FlutterStandardTypedData
        completion(.success(result))
      }
    }
  }
  /// Returns the passed list, to test serialization and deserialization.
  func echo(_ aListArg: [Any?], completion: @escaping (Result<[Any?], FlutterError>) -> Void) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoList"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aListArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! [Any?]
        completion(.success(result))
      }
    }
  }
  /// Returns the passed map, to test serialization and deserialization.
  func echo(
    _ aMapArg: [String?: Any?],
    completion: @escaping (Result<[String?: Any?], FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoMap"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aMapArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! [String?: Any?]
        completion(.success(result))
      }
    }
  }
  /// Returns the passed enum to test serialization and deserialization.
  func echo(_ anEnumArg: AnEnum, completion: @escaping (Result<AnEnum, FlutterError>) -> Void) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoEnum"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([anEnumArg.rawValue] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = AnEnum(rawValue: listResponse[0] as! Int)!
        completion(.success(result))
      }
    }
  }
  /// Returns the passed boolean, to test serialization and deserialization.
  func echoNullable(_ aBoolArg: Bool?, completion: @escaping (Result<Bool?, FlutterError>) -> Void)
  {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoNullableBool"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aBoolArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        let result: Bool? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }
  /// Returns the passed int, to test serialization and deserialization.
  func echoNullable(
    _ anIntArg: Int64?, completion: @escaping (Result<Int64?, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoNullableInt"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([anIntArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        let result: Int64? =
          isNullish(listResponse[0])
          ? nil
          : (listResponse[0] is Int64?
            ? listResponse[0] as! Int64? : Int64(listResponse[0] as! Int32))
        completion(.success(result))
      }
    }
  }
  /// Returns the passed double, to test serialization and deserialization.
  func echoNullable(
    _ aDoubleArg: Double?, completion: @escaping (Result<Double?, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoNullableDouble"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aDoubleArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        let result: Double? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }
  /// Returns the passed string, to test serialization and deserialization.
  func echoNullable(
    _ aStringArg: String?, completion: @escaping (Result<String?, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoNullableString"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aStringArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        let result: String? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }
  /// Returns the passed byte list, to test serialization and deserialization.
  func echoNullable(
    _ aListArg: FlutterStandardTypedData?,
    completion: @escaping (Result<FlutterStandardTypedData?, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoNullableUint8List"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aListArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        let result: FlutterStandardTypedData? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }
  /// Returns the passed list, to test serialization and deserialization.
  func echoNullable(
    _ aListArg: [Any?]?, completion: @escaping (Result<[Any?]?, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoNullableList"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aListArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        let result: [Any?]? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullable(
    _ aMapArg: [String?: Any?]?,
    completion: @escaping (Result<[String?: Any?]?, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoNullableMap"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aMapArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        let result: [String?: Any?]? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }
  /// Returns the passed enum to test serialization and deserialization.
  func echoNullable(
    _ anEnumArg: AnEnum?, completion: @escaping (Result<AnEnum?, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoNullableEnum"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([anEnumArg?.rawValue] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        let result: AnEnum? =
          isNullish(listResponse[0]) ? nil : AnEnum(rawValue: listResponse[0] as! Int)!
        completion(.success(result))
      }
    }
  }
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic asynchronous calling.
  func noopAsync(completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.noopAsync"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Returns the passed in generic Object asynchronously.
  func echoAsync(_ aStringArg: String, completion: @escaping (Result<String, FlutterError>) -> Void)
  {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterIntegrationCoreApi.echoAsyncString"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aStringArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! String
        completion(.success(result))
      }
    }
  }
}
/// An API that can be implemented for minimal, compile-only tests.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol HostTrivialApi {
  func noop() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class HostTrivialApiSetup {
  /// The codec used by HostTrivialApi.
  /// Sets up an instance of `HostTrivialApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: HostTrivialApi?) {
    let noopChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostTrivialApi.noop",
      binaryMessenger: binaryMessenger)
    if let api = api {
      noopChannel.setMessageHandler { _, reply in
        do {
          try api.noop()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      noopChannel.setMessageHandler(nil)
    }
  }
}
/// A simple API implemented in some unit tests.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol HostSmallApi {
  func echo(aString: String, completion: @escaping (Result<String, Error>) -> Void)
  func voidVoid(completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class HostSmallApiSetup {
  /// The codec used by HostSmallApi.
  /// Sets up an instance of `HostSmallApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: HostSmallApi?) {
    let echoChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostSmallApi.echo",
      binaryMessenger: binaryMessenger)
    if let api = api {
      echoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aStringArg = args[0] as! String
        api.echo(aString: aStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoChannel.setMessageHandler(nil)
    }
    let voidVoidChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.pigeon_integration_tests.HostSmallApi.voidVoid",
      binaryMessenger: binaryMessenger)
    if let api = api {
      voidVoidChannel.setMessageHandler { _, reply in
        api.voidVoid { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      voidVoidChannel.setMessageHandler(nil)
    }
  }
}
private class FlutterSmallApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return TestMessage.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class FlutterSmallApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? TestMessage {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class FlutterSmallApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return FlutterSmallApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return FlutterSmallApiCodecWriter(data: data)
  }
}

class FlutterSmallApiCodec: FlutterStandardMessageCodec {
  static let shared = FlutterSmallApiCodec(readerWriter: FlutterSmallApiCodecReaderWriter())
}

/// A simple API called in some unit tests.
///
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol FlutterSmallApiProtocol {
  func echo(
    _ msgArg: TestMessage, completion: @escaping (Result<TestMessage, FlutterError>) -> Void)
  func echo(_ aStringArg: String, completion: @escaping (Result<String, FlutterError>) -> Void)
}
class FlutterSmallApi: FlutterSmallApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return FlutterSmallApiCodec.shared
  }
  func echo(
    _ msgArg: TestMessage, completion: @escaping (Result<TestMessage, FlutterError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterSmallApi.echoWrappedList"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([msgArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! TestMessage
        completion(.success(result))
      }
    }
  }
  func echo(_ aStringArg: String, completion: @escaping (Result<String, FlutterError>) -> Void) {
    let channelName: String =
      "dev.flutter.pigeon.pigeon_integration_tests.FlutterSmallApi.echoString"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([aStringArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            FlutterError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! String
        completion(.success(result))
      }
    }
  }
}
